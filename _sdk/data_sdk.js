(()=>{"use strict";class Preconditions{static checkArgument(cond,msg,...args){if(!cond)throw new Error(msg==null?"invalid argument":Preconditions.format(msg,...args))}static checkState(cond,msg,...args){if(!cond)throw new Error(msg==null?"invalid state":Preconditions.format(msg,...args))}static checkEquals(a,b,msg,...args){if(a!==b)throw new Error(msg==null?Preconditions.format("{} != {}",Preconditions.stringify(a),Preconditions.stringify(b)):Preconditions.format(msg,...args))}static stringify(x){if(x==null||typeof x==="symbol")return String(x);else try{return JSON.stringify(x)}catch(e){return String(x)}}static checkExists(x,msg,...args){if(x==null)throw new Error(msg==null?"argument is null":Preconditions.format(msg,...args));return x}static format(template,...args){let i=0;return template.replace(/\{}/g,(()=>i<args.length?args[i++]:"{}"))}}class UnreachableError extends Error{constructor(x){super(`unhandled case: ${JSON.stringify(x)}`)}}class OkImpl{get ok(){return true}map(f){return new OkImpl(f(this.value))}mapError(){return this}constructor(value){this.value=value}}class ErrImpl{get ok(){return false}map(){return this}mapError(f){return new ErrImpl(f(this.error))}constructor(error){this.error=error}}const Result={Ok:OkFactory,Err:ErrFactory};function OkFactory(a){return new OkImpl(a)}function ErrFactory(x){return new ErrImpl(x)}const formattedErrorMessage=opts=>{const maybeFullstop=opts.message.endsWith(".")?"":".";return`[${opts.code}]:  ${opts.message}${maybeFullstop}`.trim()};class CanvaErrorClass extends Error{constructor(opts){opts.code=appSandboxErrorCodeMapper(opts.code);super(formattedErrorMessage(opts));this.code=opts.code;this.name="CanvaError";this.rawMessage=opts.message;Object.setPrototypeOf(this,CanvaErrorClass.prototype)}}function setAppSandboxErrorCodeMapper(mapper){appSandboxErrorCodeMapper=mapper}let appSandboxErrorCodeMapper=code=>code;class MessageBus{constructor(handler,port,errorService){this.handler=handler;this.port=port;this.errorService=errorService;this.send=message=>{try{this.port.postMessage(message);return Result.Ok()}catch(e){this.errorService.errorException(e);return Result.Err(e)}};this.onMessageError=e=>{this.errorService.errorException(e)};this.onMessage=({data})=>{if(!data){this.errorService.error(new CanvaErrorClass({code:"internal_error",message:`missing data in 'MessageEvent'`}));return}try{this.handler.receive(data)}catch(e){this.errorService.errorException(e)}};this.port.onmessage=this.onMessage;this.port.onmessageerror=this.onMessageError}}function uuidv4(rng){const randomValues=getRandomValues(rng,31);let currentRandomValue=0;return`${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g,(function(c){const cN=Number(c);return(cN^randomValues[currentRandomValue++]&15>>cN/4).toString(16)}))}function getRandomValues(rng,amount){if(!rng&&typeof window!=="undefined"&&typeof window.crypto!=="undefined"&&typeof window.crypto.getRandomValues==="function")return window.crypto.getRandomValues(new Uint8Array(amount));const random=rng??Math.random;return Array.from({length:amount},(()=>Math.floor(random()*255)))}const ACK_INTERVAL=9e3;const INITIAL_ACK_TIMEOUT=5e3;const SUBSEQUENT_ACK_TIMEOUT=2e4;class PromiseTimeoutError extends Error{constructor(){super("[internal_error] Comms promise timed out.")}}const REJECT_ON_NEXT_TICK_DELAY_MS=500;class PromiseWithTimeout{reset(newTimeoutMs){if(newTimeoutMs)this.timeoutMs=newTimeoutMs;this.setTimeout()}resolve(value){clearTimeout(this.timeoutId);this.resolveFn(value)}reject(reason){clearTimeout(this.timeoutId);this.rejectFn(reason)}promise(){return this.p}rejectOnNextTick(){this.timeoutId=setTimeout((()=>{this.rejectFn(new PromiseTimeoutError)}),REJECT_ON_NEXT_TICK_DELAY_MS)}setTimeout(){clearTimeout(this.timeoutId);this.timeoutId=setTimeout((()=>{this.rejectOnNextTick()}),Math.max(this.timeoutMs-REJECT_ON_NEXT_TICK_DELAY_MS,REJECT_ON_NEXT_TICK_DELAY_MS))}constructor(timeoutMs){this.timeoutMs=timeoutMs;this.p=new Promise(((resolve,reject)=>{this.resolveFn=resolve;this.rejectFn=reject}));this.setTimeout()}}class Client{request(path,payload){const pendingRequests=this.pendingRequests;const requestPromise=new PromiseWithTimeout(INITIAL_ACK_TIMEOUT);const requestId=this.requestIdGenerator();const resultPromise=awaitResult();const result=this.send(requestId,path,payload);if(!result.ok){this.errorService.errorException(result.error,{errorMessagePrefix:"unable to send request",tags:new Map([["type","request"],["path",path]])});requestPromise.reject(result.error)}return resultPromise;async function awaitResult(){pendingRequests.set(requestId,{path,requestPromise});try{const response=await requestPromise.promise();return Result.Ok(response)}catch(e){if(e instanceof PromiseTimeoutError)return Result.Err(new CanvaErrorClass({code:"internal_error",message:`Comms promise timed out (${path}).`}));return Result.Err(e)}finally{pendingRequests.delete(requestId)}}}handleReply(msg){const{requestId,type}=msg;const{path,requestPromise:request}=this.pendingRequests.get(requestId)||{};if(!request){if(type!=="ack")this.errorService.error(`request has already been handled and resolved or was not sent from this client`,{tags:new Map([["type",type],["requestId",`${requestId}`]])});return}switch(type){case"response":request.resolve(msg.payload);return;case"ack":request.reset(SUBSEQUENT_ACK_TIMEOUT);return;case"error":this.errorService.addBreadCrumb({level:"info",category:"sandbox_comms",message:"Error response received",data:{["path"]:path??"unknown"}});const{code,message}=msg;request.reject(new CanvaErrorClass({code,message}));return;default:throw new UnreachableError(msg)}}constructor(send,errorService,requestIdGenerator=uuidv4){this.send=send;this.errorService=errorService;this.requestIdGenerator=requestIdGenerator;this.pendingRequests=new Map}}const RequestHandlerErrorCodes={internalError:()=>"Something went wrong on our end, if this issue persists please contact us.",noHandlerForPath:path=>`No request handler configured for path: "${path}".`,handlerForPathAlreadyDefined:path=>`Handler for '${path}' is already defined.`};class RequestHandler{addErrorObserver(observer){this.errorObservers.add(observer);return()=>this.errorObservers.delete(observer)}handle(path,handler){if(this.requestHandler.has(path))throw new CanvaErrorClass({code:"internal_error",message:RequestHandlerErrorCodes.handlerForPathAlreadyDefined(path)});this.requestHandler.set(path,handler)}async handleRequest(body){const{requestId,path,payload}=body;const handler=this.requestHandler.get(path);if(!handler){const result=this.messenger.sendError(requestId,"internal_error",RequestHandlerErrorCodes.noHandlerForPath(path));if(!result.ok)this.errorService.criticalException(result.error,{errorMessagePrefix:"unable to send error response",tags:new Map([["type","request"],["path",path]])});return}this.messenger.sendAck(requestId);const intervalId=setInterval((()=>this.messenger.sendAck(requestId)),ACK_INTERVAL);let observableError;try{const resPayload=await handler(payload);clearInterval(intervalId);this.messenger.sendResponse(requestId,resPayload)}catch(e){clearInterval(intervalId);let errorCode="internal_error";let errorMessage=RequestHandlerErrorCodes.internalError();if(e instanceof CanvaErrorClass){observableError=e;if(e.code==="internal_error")this.errorService.errorException(e,{errorMessagePrefix:"Internal error in comms handler",tags:new Map([["type","request"],["path",path]])});else{errorCode=e.code;errorMessage=e.rawMessage}}else if(this.reportNonCanvaErrors)this.errorService.errorException(e,{errorMessagePrefix:"Unexpected error type thrown from comms handler",tags:new Map([["type","request"],["path",path]])});else this.devConsole.error(e);const result=this.messenger.sendError(requestId,errorCode,errorMessage);if(!result.ok)this.errorService.criticalException(result.error,{errorMessagePrefix:"unable to send error response",tags:new Map([["type","request"],["path",path]])})}if(observableError==null)return;for(const cb of this.errorObservers)try{cb(observableError)}catch(e){this.errorService.warningException(e,{errorMessagePrefix:"Error executing errorObserver"})}}constructor(messenger,errorService,reportNonCanvaErrors,devConsole=console){this.messenger=messenger;this.errorService=errorService;this.reportNonCanvaErrors=reportNonCanvaErrors;this.devConsole=devConsole;this.requestHandler=new Map;this.errorObservers=new Set}}class SandboxCommsBase{constructor(port,errorService,reportNonCanvaErrors){this.request=(path,payload)=>this.client.request(path,payload);this.handle=(path,handler)=>this.requestHandler.handle(path,handler);this.addErrorObserver=observer=>this.requestHandler.addErrorObserver(observer);const handleMessage=message=>{switch(message.type){case"ack":case"error":case"response":this.client.handleReply(message);return;case"request":this.requestHandler.handleRequest(message);return;default:throw new UnreachableError(message)}};const messenger=new MangleSafeMessageBus(handleMessage,port,errorService.createChild("bus"));this.client=new Client(messenger.sendRequest,errorService.createChild("client"));this.requestHandler=new RequestHandler(messenger,errorService.createChild("requestHandler"),reportNonCanvaErrors)}}class MangleSafeMessageBus{sendResponse(requestId,payload){return this.bus.send({["type"]:"response",["requestId"]:requestId,["payload"]:payload})}sendError(requestId,code,message){return this.bus.send({["type"]:"error",["requestId"]:requestId,["code"]:code,["message"]:message})}sendAck(requestId){return this.bus.send({["type"]:"ack",["requestId"]:requestId})}constructor(handleMessage,port,errorService){this.handleMessage=handleMessage;this.sendRequest=(requestId,path,payload)=>this.bus.send({["type"]:"request",["requestId"]:requestId,["path"]:path,["payload"]:payload});this.onReceive=message=>{switch(message["type"]){case"ack":this.handleMessage({type:"ack",requestId:message["requestId"]});return;case"error":this.handleMessage({type:"error",requestId:message["requestId"],code:message["code"],message:message["message"]});return;case"response":this.handleMessage({type:"response",requestId:message["requestId"],payload:message["payload"]});return;case"request":this.handleMessage({type:"request",requestId:message["requestId"],path:message["path"],payload:message["payload"]});return;default:throw new UnreachableError(message)}};this.bus=new MessageBus({receive:this.onReceive},port,errorService)}}const VerifyError={MISSING_DATA:"missing 'data' field in MessageEvent",MISSING_SOURCE:"'source' is missing in MessageEvent data object",INVALID_SOURCE:"invalid source",UNKNOWN_CLIENT_ID:"unknown client id"};function createInitialiseMessage(source,clientId){return{["source"]:source,["sandboxCommsSource"]:source,["clientId"]:clientId}}function verifyMessage(data,expectedSource,expectedClientId){if(!data)return Result.Err("missing 'data' field in MessageEvent");const msg=data;const source=msg["sandboxCommsSource"]??msg["source"];if(!source)return Result.Err("'source' is missing in MessageEvent data object");if(source!==expectedSource)return Result.Err("invalid source");if(msg["clientId"]!==expectedClientId)return Result.Err("unknown client id");return Result.Ok()}async function connectToParent(errorService,parentOrigin,{parent,addEventListener,removeEventListener}=window,clientId){const portPromise=Promise.withResolvers();const messageHandler=({ports,data})=>{const msg=verifyMessage(data,"parent",clientId);if(!msg.ok){switch(msg.error){case VerifyError.INVALID_SOURCE:errorService.info(msg.error,{errorMessagePrefix:"failed to verify message",extra:new Map([["data.source",data?.source]])});break;case VerifyError.MISSING_DATA:case VerifyError.MISSING_SOURCE:case VerifyError.UNKNOWN_CLIENT_ID:break;default:throw new UnreachableError(msg.error)}return}if(ports.length!==1){errorService.error("invalid number of ports received from the parent");return}const[port]=ports;portPromise.resolve(port)};addEventListener("message",messageHandler);try{const initMessage=createInitialiseMessage("iframe",clientId);parent.postMessage(initMessage,parentOrigin);const port=await portPromise.promise;return Result.Ok(new SandboxCommsBase(port,errorService.createChild("comms"),false))}catch(e){return Result.Err(e)}finally{removeEventListener("message",messageHandler)}}function deserializeRequest(message_path,proto,request){if(request===undefined)throw new CanvaErrorClass({code:"internal_error",message:`${message_path}: request cannot be undefined.`});return proto.deserialize(request)}function handleMessageFromHost(comms,message_path,messageArgProto,messageHandler,responseProto){comms.handle(message_path,(async messageObject=>{const message=deserializeRequest(message_path,messageArgProto,messageObject);const response=await messageHandler(message);if(responseProto)return responseProto.serialize(response)}))}async function runRequest(comms,messagePath,requestProto,request,responseProto){const response=await comms.request(messagePath,requestProto.serialize(request));if(!response.ok){if(response.error instanceof CanvaErrorClass)throw response.error;throw new CanvaErrorClass({code:"internal_error",message:`Something went wrong during request ${messagePath}`})}if(responseProto){if(response.value===undefined)throw new CanvaErrorClass({code:"internal_error",message:`Expected a response from ${messagePath}, but got nothing`});return responseProto.deserialize(response.value)}}const MessagePaths={INIT_DATA:"INIT_DATA",DATA_RENDER_READY:"DATA_RENDER_READY"};function isPromiseLike(p){return p!=null&&p.then!=null}function memoize(fn,{invalidateOnError}={invalidateOnError:false}){let promiseDidReject=false;let result;const memoFn=(...args)=>{Preconditions.checkArgument(args.length===0);if(result==null||invalidateOnError&&(!result.ok||promiseDidReject))try{promiseDidReject=false;result=Result.Ok(fn());if(isPromiseLike(result.value))result.value.then(null,(_e=>promiseDidReject=true))}catch(e){result=Result.Err(e)}if(result.ok)return result.value;else throw result.error};return memoFn}function memoize1(fn){const cache=new WeakMap;const memoFn=(key,...rest)=>{Preconditions.checkArgument(rest.length===0);if(!cache.has(key))cache.set(key,fn(key));return cache.get(key)};return memoFn}const MessageKind={CONCRETE:1,ONEOF:2};const FieldLabel={CONSTANT:1,REQUIRED:2,OPTIONAL:3,REPEATED:4,MAP:5};const FieldKind={PRIMITIVE:1,MESSAGE:2,ENUM:3};const makeType=t=>t;const ProtoType={STRING:makeType({typeOfValue:"string"}),BOOLEAN:makeType({typeOfValue:"boolean",defaultValue:false,fixedSize:1}),DOUBLE:makeType({typeOfValue:"number",defaultValue:0,fixedSize:8}),INT32:makeType({typeOfValue:"number",defaultValue:0}),INT64:makeType({typeOfValue:"number",defaultValue:0}),BYTES:makeType({typeOfValue:"Uint8Array"})};function constantField(params){const{tag,jsonFullKeyOrJsonMiniKey,jsonFullValue,value,defaults}=params;return{tag,fieldLabel:FieldLabel.CONSTANT,jsonFullKey:jsonFullKeyOrJsonMiniKey===DISCRIMINATOR_JSON_MINI_KEY?undefined:jsonFullKeyOrJsonMiniKey,jsonFullValue,value,defaults,typeOfValue:"string"}}function requiredField(valueType,jsonFullKey,tag,def){return{tag,fieldLabel:FieldLabel.REQUIRED,jsonFullKey,default:def!=null?def:valueType.defaultValue,defaultValue:valueType.defaultValue,typeOfValue:valueType.typeOfValue}}function optionalField(valueType,jsonFullKey,tag){return{tag,fieldLabel:FieldLabel.OPTIONAL,jsonFullKey,defaultValue:valueType.defaultValue,typeOfValue:valueType.typeOfValue}}function repeatedField(valueType,jsonFullKey,tag){return{tag,fieldLabel:FieldLabel.REPEATED,jsonFullKey,typeOfValue:valueType.typeOfValue}}function mapField(keyType,valueType){return(tagOrJsonFullKey,tagOrObj,maybeObj)=>{const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);let typeOfValue;if(valueType==="object")typeOfValue="object";else if(valueType==="enum")typeOfValue="string";else typeOfValue=valueType.typeOfValue;return{fieldLabel:FieldLabel.MAP,tag,jsonFullKey,obj,typeOfKey:keyType.typeOfValue,typeOfValue}}}class Proto{static constantString(jsonFullKeyOrJsonMiniKey,jsonFullValueOrTag,tagOrValue,maybeValue){const{tag,jsonFullKey:jsonFullValue,other1:value}=getOptions(jsonFullValueOrTag,tagOrValue,maybeValue);return constantField({tag,jsonFullKeyOrJsonMiniKey,jsonFullValue,value,defaults:false})}static constantStringWithDefault(jsonFullKeyOrJsonMiniKey,jsonFullValueOrTag,tagOrValue,maybeValue){const{tag,jsonFullKey:jsonFullValue,other1:value}=getOptions(jsonFullValueOrTag,tagOrValue,maybeValue);return constantField({tag,jsonFullKeyOrJsonMiniKey,jsonFullValue,value,defaults:true})}static requiredObject(tagOrJsonFullKey,tagOrObj,maybeObj){const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);return{tag,fieldLabel:FieldLabel.REQUIRED,jsonFullKey,obj,typeOfValue:"object"}}static optionalObject(tagOrJsonFullKey,tagOrObj,maybeObj){const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);return{tag,fieldLabel:FieldLabel.OPTIONAL,jsonFullKey,obj,typeOfValue:"object"}}static repeatedObject(tagOrJsonFullKey,tagOrObj,maybeObj){const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);return{tag,fieldLabel:FieldLabel.REPEATED,jsonFullKey,obj,typeOfValue:"object"}}static requiredStringEnum(tagOrJsonFullKey,tagOrObj,objOrDef,maybeDef){const{tag,jsonFullKey,other1:obj,other2:def}=getOptions(tagOrJsonFullKey,tagOrObj,objOrDef,maybeDef);return{tag,fieldLabel:FieldLabel.REQUIRED,jsonFullKey,obj,default:def,typeOfValue:"string"}}static optionalStringEnum(tagOrJsonFullKey,tagOrObj,maybeObj){const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);return{tag,fieldLabel:FieldLabel.OPTIONAL,jsonFullKey,obj,typeOfValue:"string"}}static repeatedStringEnum(tagOrJsonFullKey,tagOrObj,maybeObj){const{tag,jsonFullKey,other1:obj}=getOptions(tagOrJsonFullKey,tagOrObj,maybeObj);return{tag,fieldLabel:FieldLabel.REPEATED,jsonFullKey,obj,typeOfValue:"string"}}static createMessage(schema,options={}){const init=memoize((()=>{const fields=schema();const fieldNames=Object.keys(fields);const fieldsByTag={};const constantsByTag={};for(const name of fieldNames){const config=fields[name];switch(config.fieldLabel){case FieldLabel.CONSTANT:constantsByTag[config.tag]={...config,name};break;case FieldLabel.REQUIRED:case FieldLabel.OPTIONAL:case FieldLabel.REPEATED:case FieldLabel.MAP:fieldsByTag[config.tag]={...config,name};break;default:throw new UnreachableError(config)}}return{kind:MessageKind.CONCRETE,fields,fieldMetadata:deriveFieldMetadata(fields,options.dualDeserializationConfig),fieldsByTag,constantsByTag}}));class Message{static createUnchecked(opts={}){return new Message(opts)}static serialize(message){return Message.serializeWithPath(message,[])}static serializeValue(value,metadatum,path){const{config:field}=metadatum;if(field.typeOfValue==="Uint8Array")return toBase64(value);if(field.obj)return field.obj.serializeWithPath(value,path);return value}static deserialize(o){return Message.deserializeWithPath(o,[])}static deserializeValue(value,metadatum,path){const{config:field}=metadatum;if(field.typeOfValue==="Uint8Array")return fromBase64(value);if(field.obj)return field.obj.deserializeWithPath(value,path);return value}static deserializeWithPath(o,path){const{fieldMetadata}=init();const result=Object.create(Message.prototype);for(const metadatum of fieldMetadata){const{config:field,name:fieldName,primaryJsonKey,secondaryJsonKey}=metadatum;let jsonKey=primaryJsonKey;let value=o[jsonKey];if(value==null&&secondaryJsonKey!=null&&o[secondaryJsonKey]!=null){jsonKey=secondaryJsonKey;value=o[jsonKey]}switch(field.fieldLabel){case FieldLabel.OPTIONAL:if(value==null){result[fieldName]=undefined;break}else if(!isCorrectWireType(value,field.typeOfValue)){const keyEncodings={primaryJsonKey,secondaryJsonKey};throw makeOptionalTypeError(keyEncodings,value,field.typeOfValue,path)}path.push(jsonKey);result[fieldName]=Message.deserializeValue(value,metadatum,path);path.pop();break;case FieldLabel.REQUIRED:if(value==null&&field.defaultValue!=null){result[fieldName]=field.defaultValue;break}else if(value==null||!isCorrectWireType(value,field.typeOfValue)){const keyEncodings={primaryJsonKey,secondaryJsonKey};throw makeRequiredTypeError(keyEncodings,value,field.typeOfValue,path)}path.push(jsonKey);result[fieldName]=Message.deserializeValue(value,metadatum,path);path.pop();break;case FieldLabel.CONSTANT:{const{primaryJsonValue,secondaryJsonValue}=metadatum;if(value==null&&field.defaults){result[fieldName]=field.value;break}if(value===primaryJsonValue){result[fieldName]=field.value;break}if(secondaryJsonValue!=null&&value===secondaryJsonValue){result[fieldName]=field.value;break}const keyEncodings={primaryJsonKey,secondaryJsonKey};const valueEncodings={primaryJsonValue,secondaryJsonValue};throw new TypeError(`Expected value ${expectedValues(valueEncodings)} for key ${expectedKeys(keyEncodings)} found: ${JSON.stringify(value)} ${pathTrace(path)}`)}case FieldLabel.REPEATED:{if(value==null){result[fieldName]=[];break}else if(!Array.isArray(value)){const keyEncodings={primaryJsonKey,secondaryJsonKey};throw makeRepeatedTypeError(keyEncodings,value,field.typeOfValue,path)}const values=new Array(value.length);for(let j=0;j<value.length;++j){if(!isCorrectWireType(value[j],field.typeOfValue)){const keyEncodings={primaryJsonKey,secondaryJsonKey};throw makeRequiredTypeError(keyEncodings,value[j],field.typeOfValue,[...path,jsonKey],j)}path.push(`${jsonKey}[${j}]`);values[j]=Message.deserializeValue(value[j],metadatum,path);path.pop()}result[fieldName]=values;break}case FieldLabel.MAP:{if(value==null){result[fieldName]=new Map;break}else if(typeof value!=="object"){const keyEncodings={primaryJsonKey,secondaryJsonKey};throw new TypeError(`Expected Map for key ${expectedKeys(keyEncodings)}, found: ${moreSpecificTypeof(value)} ${pathTrace(path)}`)}const isNumber=field.typeOfKey==="number";const isBoolean=field.typeOfKey==="boolean";const entries=Object.entries(value);const pairs=new Array(entries.length);for(let i=0;i<entries.length;++i){const[serializedKey,serializedValue]=entries[i];let deserializedKey;if(isNumber){deserializedKey=Number(serializedKey);if(isNaN(deserializedKey))throw new TypeError(`Expected number map key, found: NaN ${pathTrace([...path,jsonKey])}`)}else if(isBoolean)switch(serializedKey){case"true":deserializedKey=true;break;case"false":deserializedKey=false;break;default:throw new TypeError(`Expected boolean map key (true or false), found: ${serializedKey} ${pathTrace([...path,jsonKey])}`)}else deserializedKey=serializedKey;if(!isCorrectWireType(serializedValue,field.typeOfValue))throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${deserializedKey}", found: ${moreSpecificTypeof(serializedValue)} ${pathTrace([...path,jsonKey])}`);path.push(`${jsonKey}["${deserializedKey}"]`);const deserializedValue=Message.deserializeValue(serializedValue,metadatum,path);path.pop();pairs[i]=[deserializedKey,deserializedValue]}result[fieldName]=new Map(pairs);break}default:throw new UnreachableError(field)}}return result}constructor(opts={}){const{fieldMetadata}=init();for(const metadatum of fieldMetadata){const{config:field,name:fieldName}=metadatum;const value=opts[fieldName];switch(field.fieldLabel){case FieldLabel.CONSTANT:this[fieldName]=field.value;break;case FieldLabel.REQUIRED:this[fieldName]=value==null?field.default:value;break;case FieldLabel.OPTIONAL:this[fieldName]=value;break;case FieldLabel.REPEATED:this[fieldName]=value==null?[]:value;break;case FieldLabel.MAP:this[fieldName]=value==null?new Map:value;break;default:throw new UnreachableError(field)}}}}Message.init=init;Message.serializeWithPath=options.unproducible?(_message,path)=>{throw new TypeError(`Unproducible oneof case ${pathTrace(path)}`)}:(message,path)=>{if(message==null||typeof message!=="object")throw new TypeError(`Expected type object, found: ${moreSpecificTypeof(message)} ${pathTrace(path)}`);const{fieldMetadata}=init();const res={};for(const metadatum of fieldMetadata){const{config:field,name:fieldName,primaryJsonKey}=metadatum;const value=message[fieldName];const jsonKey=primaryJsonKey;switch(field.fieldLabel){case FieldLabel.CONSTANT:if(value!==field.value)throw new TypeError(`Expected value ${JSON.stringify(field.value)} for key "${primaryJsonKey}", found: ${JSON.stringify(value)} ${pathTrace(path)}`);res[jsonKey]=metadatum.primaryJsonValue;break;case FieldLabel.REQUIRED:{if(field.defaultValue!=null&&value===field.defaultValue)break;path.push(jsonKey);const serializedValue=Message.serializeValue(value,metadatum,path);path.pop();if(!isCorrectWireType(serializedValue,field.typeOfValue))throw makeRequiredTypeError({primaryJsonKey},value,field.typeOfValue,path);res[jsonKey]=serializedValue;break}case FieldLabel.OPTIONAL:{if(value==null)break;path.push(jsonKey);const serializedValue=Message.serializeValue(value,metadatum,path);path.pop();if(!isCorrectWireType(serializedValue,field.typeOfValue))throw makeOptionalTypeError({primaryJsonKey},value,field.typeOfValue,path);res[jsonKey]=serializedValue;break}case FieldLabel.REPEATED:{if(value==null)break;else if(!Array.isArray(value))throw makeRepeatedTypeError({primaryJsonKey},value,field.typeOfValue,path);else if(value.length===0)break;const result=new Array(value.length);for(let i=0;i<value.length;++i){path.push(`${jsonKey}[${i}]`);const serializedValue=Message.serializeValue(value[i],metadatum,path);path.pop();if(!isCorrectWireType(serializedValue,field.typeOfValue))throw makeRequiredTypeError({primaryJsonKey},serializedValue,field.typeOfValue,[...path,jsonKey],i);result[i]=serializedValue}res[jsonKey]=result;break}case FieldLabel.MAP:{if(!(value instanceof Map))throw new TypeError(`Expected Map for key "${primaryJsonKey}", found: ${moreSpecificTypeof(value)} ${pathTrace(path)}`);else if(value.size===0)break;const map={};for(const[key,mapValue]of value){if(typeof key!==field.typeOfKey)throw new TypeError(`Expected ${field.typeOfKey} map key, found: ${moreSpecificTypeof(key)} ${pathTrace([...path,jsonKey])}`);path.push(`${jsonKey}["${key}"]`);const serializedValue=Message.serializeValue(mapValue,metadatum,path);path.pop();if(!isCorrectWireType(serializedValue,field.typeOfValue))throw new TypeError(`Expected ${field.typeOfValue} map value for map key "${key}", found: ${moreSpecificTypeof(serializedValue)} ${pathTrace([...path,jsonKey])}`);map[key]=serializedValue}res[jsonKey]=map;break}default:throw new UnreachableError(field)}}return res};return Message}static createOneof(schema,commonFields,options={}){const init=memoize((()=>{const config=schema();const discriminatorKey=Object.keys(config)[0];let discriminatorTag;let discriminatorJsonKeyEncodings;const nameToObject=new Map;const serializedToObject=new Map;const tagToObject=new Map;for(let i=0;i<config[discriminatorKey].length;i+=2){const tag=config[discriminatorKey][i];const msg=config[discriminatorKey][i+1];const msgFields=msg.init().fields;const discriminator=msgFields[discriminatorKey];if(!discriminator)throw new TypeError(`Missing discriminator.`);if(discriminator.fieldLabel!==FieldLabel.CONSTANT)throw new TypeError(`Discriminator must be FieldLabel.CONSTANT, was ${discriminator.fieldLabel}.}`);const caseDiscriminatorJsonKeyEncodings=choosePrimaryAndSecondaryJSONFromConfig(DISCRIMINATOR_JSON_MINI_KEY,discriminator.jsonFullKey,options.dualDeserializationConfig);const{primary:primaryJsonValue,secondary:secondaryJsonValue}=choosePrimaryAndSecondaryJSONFromConfig(toJsonMini(tag-1),discriminator.jsonFullValue,options.dualDeserializationConfig);tagToObject.set(tag,{Msg:msg,value:discriminator.value});nameToObject.set(discriminator.value,msg);serializedToObject.set(primaryJsonValue,msg);if(secondaryJsonValue)serializedToObject.set(secondaryJsonValue,msg);if(discriminatorJsonKeyEncodings&&discriminatorJsonKeyEncodings.primaryJsonKey!==caseDiscriminatorJsonKeyEncodings.primary)throw new TypeError(`oneOf JSON keys are not consistent. ${discriminatorJsonKeyEncodings.primaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.primary}`);if(discriminatorJsonKeyEncodings&&discriminatorJsonKeyEncodings.secondaryJsonKey!==caseDiscriminatorJsonKeyEncodings.secondary)throw new TypeError(`oneOf secondary JSON keys are not consistent. ${discriminatorJsonKeyEncodings.secondaryJsonKey} ${caseDiscriminatorJsonKeyEncodings.secondary}`);discriminatorTag=discriminator.tag;const{primary:primaryJsonKey,secondary:secondaryJsonKey}=caseDiscriminatorJsonKeyEncodings;discriminatorJsonKeyEncodings={primaryJsonKey,secondaryJsonKey}}if(discriminatorJsonKeyEncodings==null||discriminatorTag==null)throw new TypeError("OneOf has no cases.");const fields=commonFields();const fieldNames=Object.keys(fields);const fieldsByTag={};for(const name of fieldNames)fieldsByTag[fields[name].tag]={...fields[name],name};const defaultObject=options.defaultCase!=null?options.defaultCase():undefined;return{kind:MessageKind.ONEOF,fieldMetadata:deriveFieldMetadata(fields,options.dualDeserializationConfig),discriminatorKey,nameToObject,discriminatorTag,discriminatorJsonKeyEncodings,serializedToObject,defaultObject,fields,fieldsByTag,constantsByTag:{},tagToObject}}));const serializeWithPath=(t,path)=>{const{discriminatorKey,nameToObject}=init();const type=t[discriminatorKey];const obj=nameToObject.get(type);if(!obj)throw new TypeError(`Unknown oneof deserialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);return obj.serializeWithPath(t,path)};const deserializeWithPath=(o,path)=>{const{serializedToObject,discriminatorJsonKeyEncodings,defaultObject}=init();const{primaryJsonKey,secondaryJsonKey}=discriminatorJsonKeyEncodings;let type=o[primaryJsonKey];if(type==null&&secondaryJsonKey)type=o[secondaryJsonKey];if(type==null&&defaultObject)return defaultObject.deserializeWithPath(o,path);const obj=serializedToObject.get(type);if(!obj)throw new TypeError(`Unknown oneof serialized case: ${JSON.stringify(type)} ${pathTrace(path)}`);return obj.deserializeWithPath(o,path)};return{init,serialize:t=>serializeWithPath(t,[]),serializeWithPath,deserialize:o=>deserializeWithPath(o,[]),deserializeWithPath}}static createEnumUtil(schema,baseNumber=0,options={}){const init=memoize((()=>{const config=schema();const values=[];const serializedToValue=new Map;const valueToSerialized=new Map;const valueToProtobufSerialized=new Map;const protobufSerializedToValue=new Map;const unproducible=new Set;let i=0;let index=1;while(i<config.length){const value=index++;const protobufSerialized=config[i];const jsonMiniValue=toJsonMini(protobufSerialized-baseNumber);i+=1;let jsonFullValue;const maybeJsonFullValue=config[i];if(typeof maybeJsonFullValue==="string"){jsonFullValue=maybeJsonFullValue;i+=1}const{primary:primaryJsonValue,secondary:secondaryJsonValue}=choosePrimaryAndSecondaryJSONFromConfig(jsonMiniValue,jsonFullValue,options.dualDeserializationConfig);const maybeOptions=config[i];if(typeof maybeOptions==="object"&&maybeOptions.unproducible){unproducible.add(value);i+=1}values.push(value);serializedToValue.set(primaryJsonValue,value);if(secondaryJsonValue)serializedToValue.set(secondaryJsonValue,value);valueToSerialized.set(value,primaryJsonValue);valueToProtobufSerialized.set(value,protobufSerialized);protobufSerializedToValue.set(protobufSerialized,value)}return{values,valueToSerialized,valueToProtobufSerialized,protobufSerializedToValue,serializedToValue,unproducible:unproducible.size?unproducible:undefined}}));const getSerialized=(value,map,path)=>{const{unproducible}=init();if(unproducible&&unproducible.has(value))throw new TypeError(`Unproducible enum value: ${JSON.stringify(value)} ${path?pathTrace(path):""}`);const serialized=map.get(value);if(serialized==null)throw new TypeError(`The proto enum serializer failed to serialize value ${JSON.stringify(value)} into JSON.\nIt does not recognize value ${JSON.stringify(value)} as a valid member of the TypeScript enum.\n${path?pathTrace(path):""}`);return serialized};const deserializeWithPath=(jsonValue,path)=>{const value=init().serializedToValue.get(jsonValue);if(value==null)throw new TypeError(`The proto enum deserializer failed to deserialize JSON ${JSON.stringify(jsonValue)} into an enum value.\nIt does not recognize JSON ${JSON.stringify(jsonValue)} as a valid JSON value encoding of the enum.\n${pathTrace(path)}`);return value};return{values:()=>init().values,producibleValues:()=>{const{values,unproducible}=init();if(unproducible==null)return values;return values.filter((value=>!unproducible.has(value)))},serialize:value=>getSerialized(value,init().valueToSerialized,[]),serializeWithPath:(value,path)=>getSerialized(value,init().valueToSerialized,path),deserialize:jsonValue=>deserializeWithPath(jsonValue,[]),deserializeWithPath}}}Proto.requiredDouble=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.DOUBLE,jsonFullKey,tag,other1)};Proto.requiredInt32=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.INT32,jsonFullKey,tag,other1)};Proto.requiredInt64=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.INT64,jsonFullKey,tag,other1)};Proto.optionalDouble=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.DOUBLE,jsonFullKey,tag)};Proto.optionalInt32=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.INT32,jsonFullKey,tag)};Proto.optionalInt64=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.INT64,jsonFullKey,tag)};Proto.repeatedDouble=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.DOUBLE,jsonFullKey,tag)};Proto.repeatedInt32=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.INT32,jsonFullKey,tag)};Proto.repeatedInt64=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.INT64,jsonFullKey,tag)};Proto.requiredString=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.STRING,jsonFullKey,tag,other1)};Proto.optionalString=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.STRING,jsonFullKey,tag)};Proto.repeatedString=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.STRING,jsonFullKey,tag)};Proto.requiredBoolean=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.BOOLEAN,jsonFullKey,tag,other1)};Proto.optionalBoolean=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.BOOLEAN,jsonFullKey,tag)};Proto.repeatedBoolean=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.BOOLEAN,jsonFullKey,tag)};Proto.requiredBytes=(a,b,c)=>{const{tag,jsonFullKey,other1}=getOptions(a,b,c);return requiredField(ProtoType.BYTES,jsonFullKey,tag,other1)};Proto.optionalBytes=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return optionalField(ProtoType.BYTES,jsonFullKey,tag)};Proto.repeatedBytes=(a,b)=>{const{tag,jsonFullKey}=getOptions(a,b);return repeatedField(ProtoType.BYTES,jsonFullKey,tag)};Proto.booleanInt64Map=mapField(ProtoType.BOOLEAN,ProtoType.INT64);Proto.int32Int32Map=mapField(ProtoType.INT32,ProtoType.INT32);Proto.int32Int64Map=mapField(ProtoType.INT32,ProtoType.INT64);Proto.int32BoolMap=mapField(ProtoType.INT32,ProtoType.BOOLEAN);Proto.int32DoubleMap=mapField(ProtoType.INT32,ProtoType.DOUBLE);Proto.int32StringMap=mapField(ProtoType.INT32,ProtoType.STRING);Proto.int32StringEnumMap=mapField(ProtoType.INT32,"enum");Proto.int32ObjectMap=mapField(ProtoType.INT32,"object");Proto.int32BytesMap=mapField(ProtoType.INT32,ProtoType.BYTES);Proto.int64Int32Map=mapField(ProtoType.INT64,ProtoType.INT32);Proto.int64Int64Map=mapField(ProtoType.INT64,ProtoType.INT64);Proto.int64BooleanMap=mapField(ProtoType.INT64,ProtoType.BOOLEAN);Proto.int64DoubleMap=mapField(ProtoType.INT64,ProtoType.DOUBLE);Proto.int64StringMap=mapField(ProtoType.INT64,ProtoType.STRING);Proto.int64StringEnumMap=mapField(ProtoType.INT64,"enum");Proto.int64ObjectMap=mapField(ProtoType.INT64,"object");Proto.int64BytesMap=mapField(ProtoType.INT64,ProtoType.BYTES);Proto.doubleInt32Map=mapField(ProtoType.DOUBLE,ProtoType.INT32);Proto.doubleInt64Map=mapField(ProtoType.DOUBLE,ProtoType.INT64);Proto.doubleBoolMap=mapField(ProtoType.DOUBLE,ProtoType.BOOLEAN);Proto.doubleDoubleMap=mapField(ProtoType.DOUBLE,ProtoType.DOUBLE);Proto.doubleStringMap=mapField(ProtoType.DOUBLE,ProtoType.STRING);Proto.doubleStringEnumMap=mapField(ProtoType.DOUBLE,"enum");Proto.doubleObjectMap=mapField(ProtoType.DOUBLE,"object");Proto.doubleBytesMap=mapField(ProtoType.DOUBLE,ProtoType.BYTES);Proto.stringInt32Map=mapField(ProtoType.STRING,ProtoType.INT32);Proto.stringInt64Map=mapField(ProtoType.STRING,ProtoType.INT64);Proto.stringBooleanMap=mapField(ProtoType.STRING,ProtoType.BOOLEAN);Proto.stringDoubleMap=mapField(ProtoType.STRING,ProtoType.DOUBLE);Proto.stringStringMap=mapField(ProtoType.STRING,ProtoType.STRING);Proto.stringStringEnumMap=mapField(ProtoType.STRING,"enum");Proto.stringObjectMap=mapField(ProtoType.STRING,"object");Proto.stringBytesMap=mapField(ProtoType.STRING,ProtoType.BYTES);function deriveFieldMetadata(fields,dualDeserializationConfig){return Object.entries(fields).map((([name,config])=>{const fieldEncodings=deriveFieldEncodings(config,dualDeserializationConfig);return{config,name,primaryJsonKey:fieldEncodings.keyEncodings.primaryJsonKey,secondaryJsonKey:fieldEncodings.keyEncodings.secondaryJsonKey,primaryJsonValue:fieldEncodings.valueEncodings?.primaryJsonValue,secondaryJsonValue:fieldEncodings.valueEncodings?.secondaryJsonValue}}))}function deriveFieldEncodings(fieldConfig,dualDeserializationConfig){let valueEncodings;let jsonMiniKey=toJsonMini(fieldConfig.tag-1);if(fieldConfig.fieldLabel===FieldLabel.CONSTANT){const{primary:primaryJsonValue,secondary:secondaryJsonValue}=choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey,fieldConfig.jsonFullValue,dualDeserializationConfig);jsonMiniKey=DISCRIMINATOR_JSON_MINI_KEY;valueEncodings={primaryJsonValue,secondaryJsonValue}}const{primary:primaryJsonKey,secondary:secondaryJsonKey}=choosePrimaryAndSecondaryJSONFromConfig(jsonMiniKey,fieldConfig.jsonFullKey,dualDeserializationConfig);const keyEncodings={primaryJsonKey,secondaryJsonKey};return{keyEncodings,valueEncodings}}function choosePrimaryAndSecondaryJSONFromConfig(jsonMini,jsonFull,dualDeserializationConfig){if(!jsonFull){if(dualDeserializationConfig!==undefined)throw new Error("Dual Deserialization config templated but JSON full key/value wasn't");return{primary:jsonMini}}if(dualDeserializationConfig===undefined)return{primary:jsonFull};else if(dualDeserializationConfig===0)return{primary:jsonMini,secondary:jsonFull};else if(dualDeserializationConfig===1)return{primary:jsonFull,secondary:jsonMini};throw new Error("function should have been exhaustive, but wasn't")}function makeRepeatedTypeError(keyEncodings,value,expectedType,path){return new TypeError(`Expected repeated ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${moreSpecificTypeof(value)} ${pathTrace(path)}`)}function makeOptionalTypeError(keyEncodings,value,expectedType,path){return new TypeError(`Expected optional ${expectedType} value for key ${expectedKeys(keyEncodings)}, found: ${moreSpecificTypeof(value)} ${pathTrace(path)}`)}function makeRequiredTypeError(keyEncodings,value,expectedType,path,index){const atIndex=index!==undefined?` at index ${index}`:"";return new TypeError(`Expected ${expectedType} value${atIndex} for key ${expectedKeys(keyEncodings)}, found: ${moreSpecificTypeof(value)} ${pathTrace(path)}`)}function expectedKeys(keyEncodings){const{primaryJsonKey,secondaryJsonKey}=keyEncodings;if(secondaryJsonKey)return`either "${primaryJsonKey}" OR "${secondaryJsonKey}"`;return`"${primaryJsonKey}"`}function expectedValues(valueEncodings){const{primaryJsonValue,secondaryJsonValue}=valueEncodings;if(secondaryJsonValue)return`either "${primaryJsonValue}" OR "${secondaryJsonValue}"`;return`"${primaryJsonValue}"`}function pathTrace(path){return`(path: .${path.join(".")})`}function moreSpecificTypeof(value){if(value===null)return"null";if(Array.isArray(value))return"array";return typeof value}const DualDeserializationConfig={MINI_PRIMARY_FULL_SECONDARY:0,FULL_PRIMARY_MINI_SECONDARY:1};const DISCRIMINATOR_JSON_MINI_KEY="A?";const JSON_MINI_ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";function toJsonMini(x){if(x<JSON_MINI_ALPHABET.length)return JSON_MINI_ALPHABET.charAt(x);else{const builder=[];while(x>0){builder.push(JSON_MINI_ALPHABET.charAt(x%JSON_MINI_ALPHABET.length));x=Math.floor(x/JSON_MINI_ALPHABET.length)}return builder.reverse().join("")}}function getOptions(tagOrJsonFullKey,tagOrOther1,other1OrOther2,maybeOther2){if(typeof tagOrJsonFullKey==="string")return{jsonFullKey:tagOrJsonFullKey,tag:tagOrOther1,other1:other1OrOther2,other2:maybeOther2};else return{tag:tagOrJsonFullKey,other1:tagOrOther1,other2:other1OrOther2}}function isCorrectWireType(value,typeOfValue){return typeof value===typeOfValue||isCorrectBytesWireType(value,typeOfValue)}function isCorrectBytesWireType(value,typeOfValue){return typeOfValue==="Uint8Array"&&typeof value==="string"}function toBase64(bytes){const binString=Array.from(bytes,(byte=>String.fromCodePoint(byte))).join("");return btoa(binString)}function fromBase64(base64){return Uint8Array.from(atob(base64),(m=>m.codePointAt(0)))}const InitDataRequest=Proto.createMessage((()=>({})));const WebsiteContext=Proto.createMessage((()=>({deploymentId:Proto.requiredString(1),accessToken:Proto.requiredString(2)})));const InitDataResponse=Proto.createMessage((()=>({documentId:Proto.optionalString("documentId",1),elementId:Proto.optionalString("elementId",2),websiteContext:Proto.optionalObject("websiteContext",3,WebsiteContext),documentExtension:Proto.optionalString("documentExtension",5),isPreview:Proto.optionalBoolean("isPreview",4)})),{dualDeserializationConfig:DualDeserializationConfig.MINI_PRIMARY_FULL_SECONDARY});const RenderReadyRequest=Proto.createMessage((()=>({})));const RenderReadyResponse=Proto.createMessage((()=>({})));const DATA_CLIENT_ID="canva-code-data-sdk";function setupDataRequestHandlers(comms,handler){handleMessageFromHost(comms,MessagePaths.INIT_DATA,InitDataRequest,(request=>handler.handleInitData(request)),InitDataResponse);handleMessageFromHost(comms,MessagePaths.DATA_RENDER_READY,RenderReadyRequest,(request=>handler.handleRenderReady(request)),RenderReadyResponse)}class DataClientComms{async sendInitData(request){const result=await this.comms.request(MessagePaths.INIT_DATA,InitDataRequest.serialize(request));const value=extractValue(result,MessagePaths.INIT_DATA);return InitDataResponse.deserialize(value)}async sendRenderReady(request){const result=await this.comms.request(MessagePaths.DATA_RENDER_READY,RenderReadyRequest.serialize(request));const value=extractValue(result,MessagePaths.DATA_RENDER_READY);return RenderReadyResponse.deserialize(value)}constructor(comms){this.comms=comms}}function extractValue(result,messagePath){if(!result.ok)throw new Error(`Encountered an error while sending ${messagePath} request: ${result.error}`);if(result.value==null)throw new Error(`${messagePath}: Result cannot be empty`);return result.value}const SYSTEM_LOG_MARKER=Symbol("canvaSystemLog");class ConsoleErrorService{log(method,...args){console[method](SYSTEM_LOG_MARKER,`[CLIENT (${this.context})]`,...args)}createChild(name){return new ConsoleErrorService(`${this.context}:${name}`)}withOfflineStatus(){}setContext(context){this.log("debug","context set",context)}setTag(key,value){this.log("debug","tag set",key,value)}addBeforeSendHandler(){}setFilters(){}setSensitiveStrings(sensitiveStrings){}addBreadCrumb(breadCrumb){this.log("debug","breadcrumb added",breadCrumb)}debug(error,extra){this.log("debug",error,extra)}info(...args){this.log("info",...args)}warn(...args){this.log("warn",...args)}warning(error,extra){this.log("warn",error,extra)}warningException(error,extra){this.log("warn",error,extra)}error(error,extra){this.log("error",error,extra)}errorException(error,extra){this.log("error",error,extra)}critical(error,extra){this.log("error",error,extra)}criticalException(error,extra){this.log("error",error,extra)}constructor(context){this.context=context}}class SdkResult{static ok(data){return new SdkResult(true,data,undefined)}static error(error){return new SdkResult(false,undefined,error)}get isOk(){return this._success}get isError(){return!this._success}get data(){if(!this._success)throw new Error("Cannot access data on error result");return this._data}get error(){if(this._success)throw new Error("Cannot access error on success result");return this._error}constructor(_success,_data,_error){this._success=_success;this._data=_data;this._error=_error}}function createEndpointUrl(path,baseUrl){const urlString=baseUrl??window.location.href;let normalizedBase;try{const url=new URL(urlString);url.hash="";url.search="";const pathname=url.pathname;const lastSegment=pathname.split("/").pop()??"";if(lastSegment.toLowerCase().endsWith(".html")){const pathParts=pathname.split("/");pathParts.pop();url.pathname=pathParts.join("/")||"/"}normalizedBase=url.toString()}catch{normalizedBase=urlString.split("#")[0].split("?")[0]}if(normalizedBase.endsWith("/"))normalizedBase=normalizedBase.slice(0,-1);const normalizedPath=path.startsWith("/")?path:"/"+path;return normalizedBase+normalizedPath}function createEndpointUrlWithParams(path,params,baseUrl){const endpointUrl=createEndpointUrl(path,baseUrl);const url=new URL(endpointUrl);if(params){for(const[key,value]of Object.entries(params))if(value!==undefined)url.searchParams.set(key,value)}return url.toString()}const CodeletSdkSubmission=Proto.createMessage((()=>({id:Proto.requiredString(1),data:Proto.requiredString(2)})));const CreateCodeletSdkSubmissionRequest=Proto.createMessage((()=>({data:Proto.requiredString(1),documentId:Proto.optionalString(2),elementId:Proto.optionalString(3),websiteDeploymentId:Proto.optionalString(4),websiteAccessToken:Proto.optionalString(5)})));const CreateCodeletSdkSubmissionResponse=Proto.createMessage((()=>({submission:Proto.optionalObject(1,CodeletSdkSubmission)})));const FindCodeletSdkSubmissionsRequest=Proto.createMessage((()=>({documentId:Proto.optionalString(1),elementId:Proto.optionalString(2),websiteDeploymentId:Proto.optionalString(3),websiteAccessToken:Proto.optionalString(4)})));const FindCodeletSdkSubmissionsResponse=Proto.createMessage((()=>({enrichedSubmissions:Proto.repeatedObject(2,CodeletSdkSubmission),pollEveryMs:Proto.optionalInt32(3)})));const UpdateCodeletSdkSubmissionRequest=Proto.createMessage((()=>({submissionId:Proto.requiredString(1),data:Proto.requiredString(2),documentId:Proto.optionalString(3),elementId:Proto.optionalString(4),websiteDeploymentId:Proto.optionalString(5),websiteAccessToken:Proto.optionalString(6)})));const UpdateCodeletSdkSubmissionResponse=Proto.createMessage((()=>({})));const DeleteCodeletSdkSubmissionRequest=Proto.createMessage((()=>({submissionId:Proto.requiredString(1),documentId:Proto.optionalString(2),elementId:Proto.optionalString(3),websiteDeploymentId:Proto.optionalString(4),websiteAccessToken:Proto.optionalString(5)})));const DeleteCodeletSdkSubmissionResponse=Proto.createMessage((()=>({})));const MUTATION_RATE_LIMIT_MS=500;const RATE_LIMIT_THRESHOLD=5;class HttpError extends Error{constructor(message,status,statusText){super(message),this.status=status,this.statusText=statusText;this.name="HttpError"}}class FetchPersistenceService{checkRateLimit(){const now=Date.now();const timeSinceLastMutation=now-this.lastMutationTimestamp;if(timeSinceLastMutation<this.rateLimitMs){this.consecutiveRateLimitBreaches++;if(this.consecutiveRateLimitBreaches>=this.rateLimitThreshold){const waitTime=this.rateLimitMs-timeSinceLastMutation;throw new HttpError(`Rate limit exceeded. Please wait ${waitTime}ms before making another mutation request.`,429,"Too Many Requests")}}else this.consecutiveRateLimitBreaches=0;this.lastMutationTimestamp=now}async create(record,documentId,elementId,websiteContext){this.checkRateLimit();const request=new CreateCodeletSdkSubmissionRequest({data:JSON.stringify(record),documentId,elementId,websiteDeploymentId:websiteContext?.deploymentId,websiteAccessToken:websiteContext?.accessToken});const response=await fetch(createEndpointUrl("/data/create"),{method:"POST",headers:{["Content-Type"]:"application/json"},body:JSON.stringify(CreateCodeletSdkSubmissionRequest.serialize(request))});if(!response.ok)throw new HttpError(`Failed to create record: ${response.status} ${response.statusText}`,response.status,response.statusText);const responseData=await response.json();const responseProto=CreateCodeletSdkSubmissionResponse.deserialize(responseData);if(!responseProto?.submission?.id)throw new Error("Failed to create record: backend did not return an id");return{...record,__backendId:responseProto.submission.id}}async update(record,documentId,elementId,websiteContext){this.checkRateLimit();const cleanRecord={...record};delete cleanRecord.__backendId;const request=new UpdateCodeletSdkSubmissionRequest({submissionId:record.__backendId,data:JSON.stringify(cleanRecord),documentId,elementId,websiteDeploymentId:websiteContext?.deploymentId,websiteAccessToken:websiteContext?.accessToken});const response=await fetch(createEndpointUrl("/data/update"),{method:"POST",headers:{["Content-Type"]:"application/json"},body:JSON.stringify(UpdateCodeletSdkSubmissionRequest.serialize(request))});if(!response.ok)throw new HttpError(`Failed to update record: ${response.status} ${response.statusText}`,response.status,response.statusText);const responseData=await response.json();UpdateCodeletSdkSubmissionResponse.deserialize(responseData);return record}async delete(id,documentId,elementId,websiteContext){const request=new DeleteCodeletSdkSubmissionRequest({submissionId:id,documentId,elementId,websiteDeploymentId:websiteContext?.deploymentId,websiteAccessToken:websiteContext?.accessToken});const response=await fetch(createEndpointUrl("/data/remove"),{method:"POST",headers:{["Content-Type"]:"application/json"},body:JSON.stringify(DeleteCodeletSdkSubmissionRequest.serialize(request))});if(!response.ok)throw new HttpError(`Failed to delete record: ${response.status} ${response.statusText}`,response.status,response.statusText);const responseData=await response.json();DeleteCodeletSdkSubmissionResponse.deserialize(responseData)}async read(documentId,elementId,websiteContext){const response=await fetch(createEndpointUrlWithParams("/data/getAll",{document_id:documentId,element_id:elementId,website_deployment_id:websiteContext?.deploymentId,website_access_token:websiteContext?.accessToken}),{method:"GET",headers:{["Content-Type"]:"application/json"}});if(!response.ok)throw new HttpError(`Failed to read record: ${response.status} ${response.statusText}`,response.status,response.statusText);const responseData=await response.json();const submissionData=FindCodeletSdkSubmissionsResponse.deserialize(responseData);const deserializedSubmissions=[];for(const submission of submissionData.enrichedSubmissions)try{const id=submission.id;const parsed=JSON.parse(submission.data);deserializedSubmissions.push({...parsed,__backendId:id})}catch(error){throw new Error(`Failed to parse submission: ${submission}, ${error}`)}return{submissions:deserializedSubmissions,pollingRateMs:submissionData.pollEveryMs}}constructor(rateLimitMs=MUTATION_RATE_LIMIT_MS,rateLimitThreshold=RATE_LIMIT_THRESHOLD){this.rateLimitMs=rateLimitMs;this.rateLimitThreshold=rateLimitThreshold;this.lastMutationTimestamp=0;this.consecutiveRateLimitBreaches=0}}const TARGET_ORIGIN="*";const DEFAULT_POLLING_INTERVAL_MS=2500;const TERMINAL_POLLING_ERROR_CODES=[403,501];function areDataObjectsEqual(a,b){if(a===b)return true;const aKeys=Object.keys(a);const bKeys=Object.keys(b);if(aKeys.length!==bKeys.length)return false;for(const key of aKeys){if(!Object.prototype.hasOwnProperty.call(b,key))return false;const aValue=a[key];const bValue=b[key];if(!Object.is(aValue,bValue))return false}return true}function areDataObjectArraysEqual(a,b){if(a===b)return true;if(a.length!==b.length)return false;for(let index=0;index<a.length;index+=1){if(!areDataObjectsEqual(a[index],b[index]))return false}return true}class CodeletDataSdk{async setupCommsClient(){const result=await this.connectToParent(this.errorService,TARGET_ORIGIN,window,DATA_CLIENT_ID);if(!result.ok)return SdkResult.error(new Error("Failed to establish connection to parent"));this.errorService.info("Successfully connected to parent");const commsClient=this.createDataClientComms(result.value);this.commsClient=commsClient;return SdkResult.ok(commsClient)}async create(record){try{if(!this.dataHandler)return SdkResult.error(new Error("SDK must be initialized with init() before calling create()"));await this.persistenceService.create(record,this.documentId,this.elementId,this.websiteContext);const readResult=await this.read();return readResult.isError?SdkResult.error(readResult.error):SdkResult.ok(undefined)}catch(e){const error=e instanceof Error?e:new Error(String(e));return SdkResult.error(error)}}async update(record){try{if(!this.dataHandler)return SdkResult.error(new Error("SDK must be initialized with init() before calling update()"));await this.persistenceService.update(record,this.documentId,this.elementId,this.websiteContext);const readResult=await this.read();return readResult.isError?SdkResult.error(readResult.error):SdkResult.ok(undefined)}catch(e){const error=e instanceof Error?e:new Error(String(e));return SdkResult.error(error)}}async delete(record){try{if(!this.dataHandler)return SdkResult.error(new Error("SDK must be initialized with init() before calling delete()"));await this.persistenceService.delete(record.__backendId,this.documentId,this.elementId,this.websiteContext);const readResult=await this.read();return readResult.isError?SdkResult.error(readResult.error):SdkResult.ok(undefined)}catch(e){const error=e instanceof Error?e:new Error(String(e));return SdkResult.error(error)}}async read(){try{if(!this.dataHandler)return SdkResult.error(new Error("SDK must be initialized with init() before calling read()"));this.pollingState.lastReadTimestamp=Date.now();const{submissions,pollingRateMs}=await this.persistenceService.read(this.documentId,this.elementId,this.websiteContext);if(pollingRateMs&&pollingRateMs!==this.pollingState.pollingIntervalMs){this.pollingState.pollingIntervalMs=pollingRateMs;if(this.pollingState.pollingInterval!=null&&!this.pollingState.hasTerminalErrors)this.startPolling()}if(!areDataObjectArraysEqual(this.lastKnownData,submissions)){this.lastKnownData=submissions;this.dataHandler.onDataChanged(this.lastKnownData)}return SdkResult.ok(submissions)}catch(e){const error=e instanceof Error?e:new Error(String(e));return SdkResult.error(error)}}startPolling(){if(this.pollingState.hasTerminalErrors){this.errorService.warning("Not starting polling because polling was previously stopped due to errors");return}this.stopPolling();this.pollingState.pollingInterval=setInterval((async()=>{try{const timeSinceLastRead=Date.now()-this.pollingState.lastReadTimestamp;if(timeSinceLastRead<this.pollingState.pollingIntervalMs)return;const result=await this.read();if(result.isOk)this.resetErrorCount();else if(this.shouldStopPollingOnError(result.error))this.stopPolling()}catch(error){if(this.shouldStopPollingOnError(error))this.stopPolling()}}),this.pollingState.pollingIntervalMs)}stopPolling(){if(this.pollingState.pollingInterval!=null){clearInterval(this.pollingState.pollingInterval);this.pollingState.pollingInterval=null}}shouldStopPollingOnError(error){if(this.pollingState.hasTerminalErrors)return true;if(error instanceof HttpError){if(TERMINAL_POLLING_ERROR_CODES.includes(error.status)){this.errorService.error(`Stopping polling due to status ${error.status}: ${error.message}`);this.pollingState.hasTerminalErrors=true;return true}}this.pollingState.consecutiveErrorCount+=1;if(this.pollingState.consecutiveErrorCount>=5){this.errorService.error(new Error(`Stopping polling after ${this.pollingState.consecutiveErrorCount} consecutive errors.`,{cause:error}));this.pollingState.hasTerminalErrors=true;return true}this.errorService.warning(new Error(`Polling error ${this.pollingState.consecutiveErrorCount}/5`,{cause:error}));return false}resetErrorCount(){this.pollingState.consecutiveErrorCount=0}async triggerInitialReadAndPreviewReady(isPreview){try{const result=await this.read();if(!result.isOk)this.errorService.error(new Error("Failed to initialize with data",{cause:result.error}))}finally{if(isPreview)this.commsClient?.sendRenderReady(new RenderReadyRequest)}}async init(handler){try{const setupResult=await this.setupCommsClient();if(setupResult?.isError){this.errorService.error(new Error("Failed to establish connection to parent & initialize Data SDK",{cause:setupResult.error}));return SdkResult.error(setupResult.error)}const commsClient=setupResult.data;const initRes=await commsClient.sendInitData(new InitDataRequest);const{documentId,elementId,documentExtension,websiteContext}=initRes;if(documentId)this.documentId=documentId;if(elementId)this.elementId=elementId;if(documentExtension)this.documentExtension=documentExtension;if(websiteContext)this.websiteContext=websiteContext;this.dataHandler=handler;this.errorService.info("Data SDK initialized");if(initRes.isPreview&&!(initRes.documentId&&initRes.elementId)){commsClient.sendRenderReady(new RenderReadyRequest);return SdkResult.ok(undefined)}this.triggerInitialReadAndPreviewReady(initRes.isPreview);if(!initRes.isPreview)this.startPolling();return SdkResult.ok(undefined)}catch(e){const error=e instanceof Error?e:new Error(String(e));return SdkResult.error(error)}}constructor(persistenceService,connectToParent,createDataClientComms,errorService){this.persistenceService=persistenceService;this.connectToParent=connectToParent;this.createDataClientComms=createDataClientComms;this.errorService=errorService;this.dataHandler=null;this.lastKnownData=[];this.pollingState={pollingInterval:null,consecutiveErrorCount:0,hasTerminalErrors:false,pollingIntervalMs:DEFAULT_POLLING_INTERVAL_MS,lastReadTimestamp:0}}}function getErrorService(){const telemetry=window.telemetrySdk?.errorService;return telemetry?.createChild("Data")??new ConsoleErrorService("Data")}window.dataSdk=new CodeletDataSdk(new FetchPersistenceService,connectToParent,(comms=>new DataClientComms(comms)),getErrorService())})();